# -*- coding: utf-8 -*-
"""homework_3 (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jBQM4tax64mgLr6QejJiSi4WCzIxsFxm

#Homework 3: Loops, Sets & Frozensets, and File Handling

Total: 30 Questions

Rules:

No functions, list comprehensions, or generators.

Use only what we learned in class: loops (`for`, `while`, `break`, `continue`, else), `sets`/`frozensets`, and working with files (`open`, `read`, `write`, `close`, `with`).

Each task checks your ability to combine these tools in real-world scenarios.

# Part 1 — Theory Questions, write short answers as strings

Question 1. Explain the key differences between sets and frozensets in Python, including their mutability, hashability, and use cases.
"""

q1_answer = "Sets are mutable collections of unique elements and unhashable, so they can't be dictionary keys. Frozensets are immutable, hashable, and can be used as dict keys or set elements. Use sets to modify collections, frozensets when immutability is needed."

assert isinstance(q1_answer, str)
print("Theory question 1 passed!")

"""Question 2. How does the `else` clause work with Python loops, and what distinguishes it from using conditional statements inside the loop body?

"""

q2_answer ="In Python, a loop's else runs only if the loop finishes without a break. Conditionals inside the loop run during each iteration, but else runs once after the loop ends."

assert isinstance(q2_answer, str)
print("Theory question 2 passed!")

"""Question 3. Compare the efficiency of using sets versus lists for membership testing with large datasets, explaining the underlying data structures that enable this difference."""

q3_answer ="Sets use hash tables for O(1) lookups, while lists use linear search with O(n) time."


assert isinstance(q3_answer, str)
print("Theory question 3 passed!")

"""# Part 2 — Coding Practice

Each question has a description, variables, and space to write your code.

Run it — if the assert passes, your answer is correct

Question 4. Write a program that reads a text file and uses a set to find all unique words, then prints words longer than 7 characters using a loop.

Hint: Create a file then open and read that file, and collect longest words in `list`.

Hint: Choose carefully file's name, we will use it in other questions.
"""

text_content = '''
Հոգիս` տանը հաստատվել -
Տիեզերքն է ողջ պատել.
Տիեզերքի տերն եմ ես,
Ո՞վ է արդյոք նկատել։
'''
# First, write the text to a file
filename = "poem.txt"
with open(filename, "w", encoding="utf-8") as f:
    f.write(text_content)

# Now, read it back
with open(filename, "r", encoding="utf-8") as f:
    words = f.read().split()

# Use a set for unique words
unique_words = set(words)

# Find words longer than 7 characters
long_words = [w.strip('.,-–—`؟։') for w in unique_words if len(w.strip('.,-–—`؟։')) > 7]

print(long_words)


# ------------------------
assert set(long_words) == {'Տիեզերքի', 'Տիեզերքն', 'հաստատվել'}
print("Question 4 passed!")

"""Question 5. Create a while loop that collects integers from user input until encountering 'stop', then use a frozenset to store unique even numbers.

Hint: continue `while` loop and make `frozenset` out of `while` block
"""

# Simulating user input for testing
input_sequence = ['2', '4', '6', '2', '8', 'stop']
input_iter = iter(input_sequence)

numbers = set()
while True:
    user_input = next(input_iter)
    if user_input == 'stop':
        break
    num = int(user_input)
    if num % 2 == 0:
        numbers.add(num)

even_frozenset = frozenset(numbers)



# ------------------------
assert even_frozenset == frozenset({2, 4, 6, 8})
print("Question 5 passed!")

"""Question 6. Write a script that reads two files and uses `set` operations to find words present in both files but not in a predefined exclusion `set`.

Hint: Choose carefully files' names, we will use them in other questions.
"""

# Create test files
file_1 = '''
Ո՜նց է ժպտում իմ հոգին
Չարին, բարուն,― ամենքին.
Լույս է տալիս ողջ կյանքիս
Ու էն ճամփիս անմեկին։
    '''


file_2 = '''
Մընացել է բերդը մեզ,
Հաղթանակի երթը մեզ.
Անց են կացել` ով կային,
Հիմի կգա հերթը մեզ։
    '''

exclusion_set = {'Չարին', 'կային'}

# Write files
with open("file1.txt", "w", encoding="utf-8") as f:
    f.write(file_1)

with open("file2.txt", "w", encoding="utf-8") as f:
    f.write(file_2)

# Read and split words
with open("file1.txt", "r", encoding="utf-8") as f1, open("file2.txt", "r", encoding="utf-8") as f2:
    words1 = set(f1.read().split())
    words2 = set(f2.read().split())

# Find common words excluding some
common_words = (words1 & words2) - exclusion_set


# ------------------------
assert common_words == {'է'}
print("Question 6 passed!")

"""Question 7. Implement a `for`/`else` loop that processes a `list` of filenames, attempting to open each `file`. The `else clause` should execute only if all files were successfully opened."""

filenames = ["file1.txt", "file2.txt", "sample.txt"]
opened_files = []

# First, create the test files for demonstration
for fname in filenames:
    with open(fname, "w", encoding="utf-8") as f:
        f.write(f"Contents of {fname}\n")

# Process files
try:
    for fname in filenames:
        f = open(fname, "r", encoding="utf-8")
        opened_files.append(f)
    else:  # Executes only if all files opened without exception
        result = "All files opened successfully"
except FileNotFoundError:
    result = "Some files could not be opened"

# Clean up
for f in opened_files:
    f.close()

# Optional: remove test files
import os
for fname in filenames:
    os.remove(fname)

assert result == "All files opened successfully"
print("Question 7 passed!")

"""Question 8. Create a program that uses nested loops to find all anagram pairs in a word list loaded from a file, storing results in a set of frozensets"""

words = ["listen", "silent", "hello", "world", "dog", "god"]
with open("words.txt", "w") as f:
    f.write("\n".join(words))

with open("words.txt", "r") as f:
    words_list = [line.strip() for line in f]

anagram_pairs = set()

# Nested loops to find anagram pairs
for i in range(len(words_list)):
    for j in range(i + 1, len(words_list)):
        if sorted(words_list[i]) == sorted(words_list[j]):
            anagram_pairs.add(frozenset([words_list[i], words_list[j]]))



# ------------------------
expected = {frozenset({'listen', 'silent'}), frozenset({'dog', 'god'})}
assert anagram_pairs == expected
print("Question 8 passed!")

"""Question 9. Write a function that accepts a file path and returns a frozenset of all words containing at least two different vowels, using a while loop for reading.

"""

# Create the sample file first
sample_text = '''
Արեւը լուսավորում է երկիրը
Ուլունքները հոսում են գետում
Հոգիս ուրախ է
'''
with open("sample.txt", "w", encoding="utf-8") as f:
    f.write(sample_text)

# Function definition
def find_multi_vowel_words(filepath):
    vowels = set('աէըիօու')
    result_words = set()

    with open(filepath, "r", encoding="utf-8") as f:
        while True:
            line = f.readline()
            if not line:  # End of file
                break
            for word in line.split():
                unique_vowels = set(c for c in word if c in vowels)
                if len(unique_vowels) >= 2:
                    result_words.add(word.strip('.,-–—`؟։'))

    return frozenset(result_words)

# Call the function
multi_vowel_words = find_multi_vowel_words("sample.txt")
assert len(multi_vowel_words) > 0
print("Question 9 passed!")

"""Question 10. Implement a password validator that reads common passwords from a `file` into a `set`, then uses a `while` loop to repeatedly prompt until a unique password is given.

"""

common_passwords = {"password", "123456", "qwerty", "letmein"}
with open("common_passwords.txt", "w", encoding="utf-8") as f:
    for pw in common_passwords:
        f.write(pw + "\n")

# ------------------------

# Step 2: Read the file into a set
common_set = set()
with open("common_passwords.txt", "r", encoding="utf-8") as f:
    for line in f:
        common_set.add(line.strip())

# ------------------------

# Step 3: Simulate user input
test_passwords = ["password", "123456", "MySecurePass123!"]
test_input = iter(test_passwords)

valid_password = None
attempts = 0
max_attempts = 5

# Step 4: Validate password using while loop
while attempts < max_attempts:
    password = next(test_input, "quit")
    if password == "quit":
        break
    attempts += 1
    if password not in common_set:
        valid_password = password
        break

# ------------------------
assert valid_password == "MySecurePass123!"
print("Question 10 passed!")

"""Question 11. Create a script that processes a log file using a `for` loop, counting unique IP addresses with a `set`, and writing suspicious IPs (appearing >10 times) to a new file.

Hint: Create log file -> initalize empty `dictionary` -> open and read log file, cound unique ips counts using `dictionary` `ip_count[ip] = ip_count.get(ip, 0) + 1`  -> filter `dictionary` -> open and write suspicious ips in a new file
"""

log_content = """192.168.1.1 - GET /home
192.168.1.2 - POST /login
192.168.1.1 - GET /profile
192.168.1.3 - GET /home
192.168.1.1 - POST /submit
192.168.1.1 - GET /home
192.168.1.1 - GET /home
192.168.1.1 - GET /home
192.168.1.1 - GET /home
192.168.1.1 - GET /home
192.168.1.1 - GET /home
192.168.1.1 - GET /home
192.168.1.1 - GET /home
192.168.1.2 - GET /home"""

ip_count = {}
for line in log_content.splitlines():
    ip = line.split()[0]
    ip_count[ip] = ip_count.get(ip, 0) + 1

# Filter suspicious IPs (>10 times)
suspicious_ips = {ip for ip, count in ip_count.items() if count > 10}


# ------------------------
assert suspicious_ips == {'192.168.1.1'}
print("Question 11 passed!")

"""Question 12. Write a program that uses `zip()` in a `for` loop to compare corresponding lines from two files, storing differences in a `set` of `tuples` (line_num, text1, text2).

"""

with open("compare1.txt", "w") as f:
    f.write('''
Լինե՜ր հեռու մի անկյուն,
Լինե՜ր մանկան արդար քուն,
Երազի մեջ տխուր,
Հաշտ ու խաղաղ մարդկություն։
''')

with open("compare2.txt", "w") as f:
    f.write('''
Լինե՜ր հեռու մի անկյուն,
Լինե՜ր մանկան արդար քուն,
Երազի մեջ երջանիկ,
Հաշտ ու խաղաղ մարդկություն։
''')
differences = set()
with open("compare1.txt", "r", encoding="utf-8") as f1, open("compare2.txt", "r", encoding="utf-8") as f2:
    for i, (l1, l2) in enumerate(zip(f1, f2), start=1):
        if l1 != l2:
            differences.add((i, l1.rstrip("\n"), l2.rstrip("\n")))


# ------------------------
assert differences == {(4, 'Երազի մեջ տխուր,', 'Երազի մեջ երջանիկ,')}
print("Question 12 passed!")

"""Which quartet is the original?

Question 13. `set` comprehension is implemented that generates prime numbers up to N using the Sieve of Eratosthenes algorithm. Serialize the result to a file.
"""

def sieve_primes(n):
    if n < 2:
        return set()
    sieve = [True] * (n + 1)
    sieve[0] = sieve[1] = False
    for i in range(2, int(n**0.5) + 1):
        if sieve[i]:
            for j in range(i*i, n + 1, i):
                sieve[j] = False
    return {i for i in range(2, n + 1) if sieve[i]}

primes = sieve_primes(30)
with open("primes.txt", "w", encoding="utf-8") as f:
    f.write(",".join(map(str, sorted(primes))))


# ------------------------
assert primes == {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}
print("Question 13 passed!")

"""Question 14. Create a menu system with while/else that lets users: 1) Add words to a set from input, 2) Save set to file, 3) Load set from file, 4) Exit.

"""

word_set = set()
input_sequence = []  # No words added
input_iter = iter(input_sequence)

menu_choices = iter(["2", "4"])  # Save and exit
result = "Normal exit"

while True:
    menu_choice = next(menu_choices, "4")
    if menu_choice == "1":
        while True:
            word = next(input_iter, "done")
            if word == "done":
                break
            word_set.add(word)
    elif menu_choice == "2":
        with open("words.txt", "w", encoding="utf-8") as f:
            for w in word_set:
                f.write(w + "\n")
    elif menu_choice == "3":
        try:
            with open("words.txt", "r", encoding="utf-8") as f:
                word_set = set(line.strip() for line in f)
        except FileNotFoundError:
            pass
    elif menu_choice == "4":
        break
else:
    result = "Loop completed normally"

assert len(word_set) == 0
print("Question 14 passed!")

"""Question 15. Write a function that uses enumerate() in a for loop to process a list of filenames, creating a dictionary {index: frozenset_of_unique_words} for each valid file.

"""

def process_files(filenames):
    result = {}
    for idx, fname in enumerate(filenames):
        try:
            with open(fname, "r", encoding="utf-8") as f:
                words = f.read().split()
                result[idx] = frozenset(words)
        except FileNotFoundError:
            # Skip the file or assign empty frozenset
            result[idx] = frozenset()
    return result

# Example usage
file_dict = process_files(["file1.txt", "file2.txt", "sample.txt"])

assert all(isinstance(val, frozenset) for val in file_dict.values())
print("Question 15 passed!")

"""Question 16. Implement a program that reads a CSV file, uses set operations to find overlapping values between columns, and writes results using a context manager.

"""

# Create CSV with potential overlaps
csv_content = """id,name,department,manager_id
1,John,Engineering,3
2,Alice,Engineering,3
3,Bob,Management,5
4,Charlie,Engineering,3
5,David,Management,5
3,Bob,Management,5"""  # Note: Bob appears as both id and manager_id

# Write CSV file
with open("data.csv", "w", encoding="utf-8") as f:
    f.write(csv_content)

# Read CSV and build sets for each column
with open("data.csv", "r", encoding="utf-8") as f:
    lines = f.readlines()

headers = lines[0].strip().split(',')
data = {header: set() for header in headers}

for line in lines[1:]:
    values = line.strip().split(',')
    for header, value in zip(headers, values):
        data[header].add(value)

# Find overlaps between columns
overlaps = {}
for i, header1 in enumerate(headers):
    for header2 in headers[i+1:]:
        common = data[header1] & data[header2]
        if common:
            overlaps[f"{header1}_{header2}"] = common

# Find values appearing in multiple columns
all_values = {}
for header in headers:
    for value in data[header]:
        all_values[value] = all_values.get(value, []) + [header]

multi_column_values = {value: columns for value, columns in all_values.items() if len(columns) > 1}

# Write results to file
with open("overlaps.txt", "w", encoding="utf-8") as f:
    f.write("OVERLAPS BETWEEN COLUMNS:\n")
    for key, values in overlaps.items():
        f.write(f"{key}: {values}\n")

    f.write("\nVALUES IN MULTIPLE COLUMNS:\n")
    for value, columns in multi_column_values.items():
        f.write(f"{value}: {columns}\n")

# ------------------------
assert overlaps['id_manager_id'] == {'3', '5'}
assert len(multi_column_values) > 0
print("Question 16 passed!")

"""Question 17. Create a while loop that generates random numbers (1-100) until it collects 15 unique primes, storing them in a frozenset and logging each attempt to a file.

"""

import random

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True  # Fixed indentation

prime_set = set()
attempts_log = []

while len(prime_set) < 15:
    num = random.randint(1, 100)
    attempts_log.append(f"Generated: {num}")
    if is_prime(num):
        prime_set.add(num)

prime_frozenset = frozenset(prime_set)

with open("prime_search.log", "w", encoding="utf-8") as f:
    for entry in attempts_log:
        f.write(entry + "\n")

# ------------------------
assert len(prime_frozenset) == 15
assert all(is_prime(p) for p in prime_frozenset)
print("Question 17 passed!")

"""Question 18. Write a script that compares three text files using set symmetric_difference operations, highlighting words unique to each file through nested loops.

"""

with open("text1.txt", "w") as f:
    f.write("apple banana cherry")
with open("text2.txt", "w") as f:
    f.write("banana date elderberry")
with open("text3.txt", "w") as f:
    f.write("cherry fig grape")

def read_words(filename):
    with open(filename, 'r') as f:
        return set(f.read().split())

set1 = read_words("text1.txt")
set2 = read_words("text2.txt")
set3 = read_words("text3.txt")

unique_words = {}
files = [set1, set2, set3]
filenames = ["text1.txt", "text2.txt", "text3.txt"]

for i, current_set in enumerate(files):
    # union of all other sets
    other_sets = set()
    for j, s in enumerate(files):
        if j != i:
            other_sets |= s
    unique_words[filenames[i]] = current_set - other_sets  # words only in current set

# ------------------------
assert len(unique_words['text1.txt']) == 1
assert unique_words['text2.txt'] == {'date', 'elderberry'}
assert unique_words['text3.txt'] == {'fig', 'grape'}
print("Question 18 passed!")

"""Question 19. Implement a for loop with break/continue that processes a list mixed with filenames and strings, reading files into a set while skipping invalid entries.

"""

mixed_list = ["file1.txt", "invalid_file.xyz", "sample.txt", "random_string"]
combined_words = set()

for item in mixed_list:
    if not item.endswith('.txt'):
        continue  # Skip non-text items

    try:
        with open(item, 'r', encoding='utf-8') as f:
            combined_words.update(f.read().split())
    except FileNotFoundError:
        break  # Stop processing if file is missing

# ------------------------
assert len(combined_words) >= 0
print("Question 19 passed!")

"""Question 20. Create a program that uses a set to track visited URLs in a web crawler simulation, with a while loop that stops when no new unique URLs are found."""

visited_urls = set()
new_urls = {"http://example.com/page1"}

iterations = 0
max_iterations = 10

while new_urls and iterations < max_iterations:
    # Pop a URL from new_urls and add it to visited_urls
    current_url = new_urls.pop()
    visited_urls.add(current_url)

    # Simulate finding new links
    if "page1" in current_url:
        new_urls.add("http://example.com/page2")
    elif "page2" in current_url:
        new_urls.add("http://example.com/page3")

    # Only keep URLs that haven’t been visited yet
    new_urls = new_urls - visited_urls
    iterations += 1

# ------------------------
assert len(visited_urls) >= 3
print("Question 20 passed!")

"""Question 21. Write a function that accepts a directory path and returns a frozenset of all unique file extensions found, using os.listdir() and a for loop.


"""

import os

# Create test files
test_files = ["doc1.pdf", "image.jpg", "data.csv", "script.py", "readme.md"]
for file in test_files:
    with open(file, "w", encoding="utf-8") as f:
        f.write("test")  # just some content

# Function to get unique file extensions as frozenset
def get_extensions(directory):
    extensions = set()
    for filename in os.listdir(directory):
        if '.' in filename:
            ext = filename.split('.')[-1]
            extensions.add(ext)
    return frozenset(extensions)

# Call the function
extensions = get_extensions('.')

# Cleanup
for file in test_files:
    if os.path.exists(file):
        os.remove(file)

assert len(extensions) >= 4
print("Question 21 passed!")

"""Question 22. Implement a program that reads a configuration file, uses a set to validate unique section headers, and rewrites the file with duplicates removed using a while loop.


"""

config_content = "[database]\nhost=localhost\n[database]\nport=5432\n[app]\ndebug=true\n[database]\nname=test"
with open("config.ini", "w", encoding="utf-8") as f:
    f.write(config_content)

seen_headers = set()
cleaned_lines = []

with open("config.ini", "r", encoding="utf-8") as f:
    lines = f.readlines()
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith("[") and line.endswith("]"):
            if line in seen_headers:
                i += 1
                while i < len(lines) and not lines[i].strip().startswith("["):
                    i += 1
                continue
            seen_headers.add(line)
        cleaned_lines.append(line)
        i += 1

with open("config_clean.ini", "w", encoding="utf-8") as f:
    f.write("\n".join(cleaned_lines))

assert len(seen_headers) == 2
print("Question 22 passed!")

"""Question 23. Create a script that processes a large file in chunks using a while loop, maintaining a set of unique character sequences, and periodically saving progress.

"""

test_content = "Դու մի՛ հավատա ժըպտուն աչքերին," * 10
with open("large_file.txt", "w", encoding="utf-8") as f:
    f.write(test_content)

chunk_size = 15
unique_sequences = set()
position = 0

with open("large_file.txt", "r", encoding="utf-8") as file:
    while True:
        chunk = file.read(chunk_size)
        if not chunk:
            break
        unique_sequences.add(chunk)
        position += len(chunk)

        # Optional: save progress periodically
        # with open("progress.txt", "w", encoding="utf-8") as pf:
        #     pf.write("\n".join(unique_sequences))

assert len(unique_sequences) > 20
print("Question 23 passed!")

"""Question 24. Write a program that uses set operations (union, intersection) to merge multiple word lists from different files, then sorts results using a for loop.


"""

with open("list1.txt", "w") as f:
    f.write('''
Ա՛նց կացա՜ն…
Ախ ու վախով, դարդերով
Սիրտըս կերա՜ն, ա՛նց կացա՜ն։
''')

with open("list2.txt", "w") as f:
    f.write('''
Օրերս թռան, ա՛նց կացա՜ն.
Ախ ու վախով, դարդերով
Սիրտըս կերա՜ն, ա՛նց կացա՜ն։
''')

with open("list3.txt", "w") as f:
    f.write('''
Ա՛նց կացա՜ն…
Սիրտըս կերա՜ն, ա՛նց կացա՜ն։
''')

file_list = ["list1.txt", "list2.txt", "list3.txt"]
all_words = set()
common_words = None

for i, filename in enumerate(file_list):
    with open(filename, "r") as f:
        words = set(f.read().split())
        all_words |= words
        if common_words is None:
            common_words = words
        else:
            common_words &= words

sorted_all = sorted(all_words)
sorted_common = sorted(common_words)

assert len(sorted_all) >= 6
assert len(sorted_common) >= 0
print("Question 24 passed!")

"""Question 25. Implement a while loop that monitors a log file for new entries, maintaining a frozenset of unique error codes and alerting when new codes appear.


"""

import time

log_entries = [
    "ERROR 404: Not found",
    "INFO: User logged in",
    "ERROR 500: Server error",
    "ERROR 404: Not found",
    "ERROR 503: Service unavailable"
]

error_codes = set()
new_errors_detected = []

i = 0
while i < len(log_entries):
    line = log_entries[i]
    if line.startswith("ERROR"):
        code = line.split()[1].strip(":")
        if code not in error_codes:
            error_codes.add(code)
            new_errors_detected.append(code)
    i += 1
    # simulate small delay (not required for logic)
    time.sleep(0.01)

error_codes = frozenset(error_codes)

# ------------------------
assert len(new_errors_detected) == 3
print("Question 25 passed!")

"""

```
# This is formatted as code
```

Question 26. Create a program that reads a JSON file, extracts all nested keys using recursive loops, and stores them in a frozenset for immutable access.

"""

import json

sample_data = {
    "user": {
        "name": "John",
        "address": {
            "street": "Main St",
            "city": "Boston"
        }
    },
    "settings": {
        "theme": "dark",
        "notifications": True
    }
}

# --- Write sample_data into data.json ---
with open("data.json", "w") as f:
    json.dump(sample_data, f, indent=2)

# ------------------------

def extract_keys(obj, current_path=""):
    keys = set()
    if isinstance(obj, dict):
        for key, value in obj.items():
            full_key = f"{current_path}.{key}" if current_path else key
            keys.add(full_key)
            keys.update(extract_keys(value, full_key))
    elif isinstance(obj, list):
        for i, item in enumerate(obj):
            keys.update(extract_keys(item, f"{current_path}[{i}]"))
    return keys

# --- Read the JSON file ---
with open("data.json", "r") as f:
    data = json.load(f)

# ------------------------

all_keys = extract_keys(data)
keys_frozenset = frozenset(all_keys)

assert len(keys_frozenset) >= 6
print("Question 26 passed!")

"""Question 27. Write a script that uses a set comprehension with conditional logic to filter words from a file based on length and character composition, then saves to a new file.

"""

with open("words.txt", "w") as f:
    f.write('''
Աշնան ամպին ու զամպին,
Մոլոր նըստած իր ճըմբին,
Լոռու հանդում մի արտուտ
Նայում է միշտ իմ ճամփին։
    ''')

# --- Read the file ---
with open("words.txt", "r") as f:
    content = f.read()

# ------------------------
filtered_words = {word for word in content.split()
                  if len(word) > 6 and any(c.isalpha() for c in word)}

# --- Save sorted filtered words ---
with open("filtered_words.txt", "w") as f:
    for word in sorted(filtered_words):
        f.write(word + "\n")

# ------------------------
assert len(filtered_words) >= 4
print("Question 27 passed!")

"""Question 28. Implement a for loop that processes a list of data files, using try/except to handle missing files, and accumulates all unique values in a master set."""

data_files = ["file1.txt", "missing_file.txt", "file2.txt", "sample.txt"]
master_set = set()

for filename in data_files:
    try:
        with open(filename, "r") as f:
            master_set.update(f.read().split())
    except FileNotFoundError:
        continue

# ------------------------
assert len(master_set) >= 0
print("Question 28 passed!")

"""Question 29. Create a program that uses a while loop to accept mathematical set operations (union, intersect) on frozensets loaded from files, with persistent storage."""

# Create test frozenset files
set_a = frozenset({1, 2, 3, 4, 5})
set_b = frozenset({4, 5, 6, 7, 8})

with open("set_a.txt", "w") as f:
    f.write("\n".join(map(str, set_a)))
with open("set_b.txt", "w") as f:
    f.write("\n".join(map(str, set_b)))

def load_frozenset(filename):
    with open(filename, 'r') as f:
        return frozenset(int(line.strip()) for line in f)

set1 = load_frozenset("set_a.txt")
set2 = load_frozenset("set_b.txt")

# Simulate operations
operations = ["union", "intersect", "quit"]
op_iter = iter(operations)
results = []

while True:
    operation = next(op_iter)
    if operation == "union":
        results.append(set1 | set2)
    elif operation == "intersect":
        results.append(set1 & set2)
    elif operation == "quit":
        break

# ------------------------
# Save final result
with open("set_results.txt", "w") as f:
    for res in results:
        f.write(str(sorted(res)) + "\n")

# ------------------------
assert len(results) == 2
print("Question 29 passed!")

"""# Bonus Task
You have an opportunity to earn extra credit by completing this final question.

Question 30. There is a pickle file `bonus_task.pkl` in the current directory.Write a program to open the file and extract the data. Then, print the data and answer the question from pickle file.
"""

import pickle

with open("bonus_task.pkl", "rb") as f:
    data = pickle.load(f)

print(data)